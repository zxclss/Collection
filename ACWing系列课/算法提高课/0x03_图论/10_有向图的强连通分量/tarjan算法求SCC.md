# Tarjan算法求强连通分量（SCC）
1. 对每个点定义两个时间戳：
    1. `dfn[u]` 表示遍历到的 `u` 的时间戳。
    2. `low[u]` 从 `u` 开始走，所能遍历到的最小时间戳是什么。
2. 如果 `u` 是其所在的强联通分量的最高点，等价于 `dfn[u] == low[u]`

然后对于强联通分量进行缩点，就会得到一个拓扑图
> 按照dfs序列得到的强连通分量SCC的id号的逆序，就是拓扑排序序列
> 因为第一个被搜到的强联通分量其一定是不能再到其他任何一个点的，即当前点的所有后继已被搜完，那么它毫无疑问就是拓扑排序的最后一个元素

## 模板
```c++
//dfn[u] 表示遍历到的 u 的时间戳。
//low[u] 从 u 开始走，所能遍历到的最小时间戳是什么。
void tarjan(int u) {
    dfn[u] = low[u] = ++timestamp;      //初始化当前点的dfn和low
    stk[++top] = u, in_stk[u] = true;   //当前点如栈
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        //按照dfs序列，其后面的点都是没有遍历过的点，直接遍历
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (in_stk[j]) {
            //如果那个点还在栈中
            //说明出现了一个强连通分量SCC，而且当前这个强连通分量还没有被遍历完
            //则这个j，要么是当前点u的祖先，要么是u通过横叉边连到另一个强联通分量
            //无论如何，这个j的时间戳都必定小于当前u的时间戳
            //我们就用他的时间戳来更新一下u的low
            low[u] = min(low[u], dfn[j]);
            //这个条件对应的情况就是，当前节点的有一条边连回去构成了一个环
        }
    }
    //如果 u 是其所在的强联通分量的最高点，等价于 dfn[u] == low[u]
    //就是要么当前点出度为零(叶子结点)，要么扫了一圈又回到了自己
    //此时栈中存储了两个u，两个u之间就是该SCC的所有点了
    //我们就把这个强联通分量给存储下来
    if (dfn[u] == low[u]) {
        int y;
        ++scc_cnt;
        do {
            y =  stk[top--];
            in_stk[y] = false;
            id[y] = scc_cnt;        //统计点i属于的SCC的id
            ++scc_size[scc_cnt];    //统计SCC内的点数量
        } while (y != u)    //用do_while可以顺带把第二个u也清楚掉
    }
}
```