```c++
#include <iostream>
#include <cstring>
using namespace std;

/*
--------------------------------------
状态机模型:
点:
    状态1: 手中持有股票
    状态2: 手中没有股票
边:
    状态1 -> 状态1: 持有股票，继续持仓
    状态2 -> 状态2: 没有股票，继续观望
    状态1 -> 状态2: 持有股票，清仓全抛
    状态2 -> 状态1: 没有股票，购入持仓
初始状态机：
    f(0, 0, 0) = 0
    f(0, 0, 1) = -INF (一开始不可能持有股票，不然在遇到第一支股票会直接抛掉不存在的股票)
                      (因此把这种情况的收益设置成负无穷，以防会计算他)
---------------------------------------
闫氏DP分析法:
f(i, j, k)状态表示:
    集合: 只考虑前i天，当前完成购入股票的次数为j,且当前状态为k(1-持仓，0-没有)的方案
    属性: Max (方案的收益最大值)
f(i, j, k)状态计算:
    状态1的集合计算: f(i, j, 1) = max(f(i-1, j, 1), f(i-1, j-1, 0) - w(i));
    状态2的集合计算: f(i, j, 0) = max(f(i-1, j, 0), f(i-1, j, 1) + w(i));
初始要初始化“不进行交易就出现持股”的状态f(i, 0, 1)为负无穷，避免这种状态更新我们的最大值
因此我们直接把全部初始化为负无穷，并把初始合法的状态都手动修改为0即可
*/

const int N = 1e5 + 10, M = 110, INF = 1e9;
int n, m;
int w[N];
int f[N][M][2];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &w[i]);

    //初始化
    memset(f, -0x3f, sizeof f);
    for (int i = 0; i <= n; ++i) f[i][0][0] = 0;

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);
            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);
        }
    }
    int res = 0;
    for (int i = 1; i <= m; ++i) res = max(res, f[n][i][0]);
    cout << res << endl;
    return 0;
}
```

