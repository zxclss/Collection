# 线段树

1. 线段树的每个节点都代表一个区间。
2. 线段树具有唯一的根结点，代表的区间是整个统计范围，如 $[1, N]$。
3. 线段树的每个叶结点都代表一个长度为 $1$ 的元区间 $[x, x]$。
4. 对于每个内部结点 $[l,r]$，他的左子结点是 $[l, mid]$，右子结点是 $[mid + 1, r]$，其中$mid = \lfloor\dfrac{l + r}{2} \rfloor$。



### 线段树Tip

1. 线段树是一棵非常漂亮二叉树，（除了最后一层外，是一棵满二叉树），因此我们采用**堆**的思想来存整棵树

    1. 编号 $x$ 的父节点：$\lfloor\dfrac{x}{2} \rfloor$ ，常书写的代码：`x >> 1`
    2. 编号 $x$ 的左儿子：$2x$  ，常书写的代码：`x << 1`
    3. 编号 $x$ 的右儿子：$2x + 1$ ，常书写的代码：`x << 1 | 1`

2. 线段树的下一层都是把当前层进行平分 $mid = \lfloor\dfrac{l + r}{2} \rfloor$

    1. 左区间为 $[l, mid]$

    2. 右区间为 $[mid + 1, r]$

        **注意，线段树的两个子区间是不允许相交的**

        **这也决定了许多题的分块要进行额外的操作，使之区间不能相交**

3. 线段树一般开长度为 $4N$ 的空间

    1. 一个长度为 $N$ 的区间，最终的叶结点，为 $N$ 个
    2. 先考虑理想状态下（包含最后一层，整个二叉树都是满二叉树），$N$ 个叶结点的满二叉树有 $N + \dfrac{N}{2} + \dfrac{N}{4} + ··· + 2 + 1 = 2N - 1$ 个结点。
    3. 但是线段树的存储方式下，最后一层还会有盈余，最坏情况下，最后一层是倒数第二层（也就是满二叉树的倒数第一层）两倍的点，所以所以保存线段树的数组长度要不小于 $4N$ 才能保证不会越界



### 线段树的模版

1. **pushup()**：由子结点的信息来计算父结点的信息

    ```c++
    //此处演示的模板是找区间最大值
    void pushup(int u) {
        tr[u].v = max(tr[u << 1].v, tr[u << 1 | 1].v);
    }
    ```

    

2. **build()**：将一段区间初始化为线段树

    ```c++
    void buid(int u, int l, int r) {
        tr[u] = {l, r};
        if (l == r) return;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    ```

    

3. **modify()**：修改

    1. 单点修改（easy）

        ```c++
        void modify(int u, int x, int v) {
            if (tr[u].l == tr[u].r) tr[u].v = v;
            else {
                int mid = tr[u].l + tr[u].r >> 1;
                if (x <= mid) modify(u << 1, x, v);
                else modify(u << 1 | 1, x, v);
                pushup(u);
            }
        }
        ```

    2. 区间修改（hard）：用到pushdown操作，懒标记思想

4. **query()**：区间询问（例如：查询 $[a, b]$ 区间）$O(\log n)$最多是$4\log n$的时间，因为最坏有两条链

    1. $[l, r] \supset [T_l, T_r]$，直接返回

    2. $[l,r] \cap [T_l, T_r] \ne \varnothing$，递归下去

        1. $l \le T_l \le r \le T_r$：
            1. $r \le T_{mid}$：只递归左半边
            2. $T_{mid} \lt r$：递归左半边 + 递归右半边（但右子树完全包含，只递归一层就返回了）
        2. $T_l \le l \le T_r \le r$ 与上述对称，类比即可
        3. $T_l \le l \le r \le T_r$：
            1. $r \le T_{mid}$：只递归左半边
            2. $T_{mid} \lt l$：只递归右半边
            3. $l \le T_{mid} \lt r$：递归左半边 + 递归右半边

    3. $[l,r] \cap [T_l, T_r] = \varnothing$，不存在这种可能，因为初始区间包含了合法的所有范围。

        ```c++
        int query(int u, int l, int r) {
            if (l <= tr[u].l && tr[u].r <= r) return tr[u].v;
            int mid = tr[u].l + tr[u].r >> 1;
            int v = 0;
            if (l <= mid) v = query(u << 1, l ,r);
            if (r > mid) v = max(v, query(u << 1 | 1, l, r)); 	//此处演示的模板是找区间最大值
            return v;
        }
        ```



### 线段树的进阶运用

1. **懒标记**（**pushdown**操作）

    常用**pushup**操作只能高效进行单点修改$O(\log n)$。

    如果涉及区间修改的话，只有**pushup**会导致时间复杂度到$O(n)$。

    因此涉及区间修改，我们需要**pushdown**操作。

    

    **pushdown**操作灵感来源于**query**操作。

    就是当**修改区间**覆盖了当前**线段区间**时，给该区间打上一个**标记**，并返回，而不是继续向下修改。

    **懒标记**含义：以当前结点为根的子树中的每一个结点都执行**该操作**。

    （例如区间修改值的操作，懒标记就是**add**：给所有子树都加上该懒标记的值）

    注：懒标记是不包含根结点的，只代表修改他的子树。（一般规定）

    

    所以就会出现一个问题，查询一个子区间的时候，他的实际值应该要考虑他所有祖宗结点的懒标记值。

    为了解决这个问题，当我们执行 **从上往下**  **递归** 的时候，**每次递归**就要在到下一层之前执行一次**pushdown**操作，把根结点的**懒标记**传递到所有子节点上，然后更新**子节点**的**懒标记**和**值**，同时再把根结点的**懒标记**清空。

    

    

2. **扫描线法**（线段树的经典运用，建议背过）

    具体详见 [AcWing 247. 亚特兰蒂斯](https://www.acwing.com/file_system/file/content/whole/index/content/2153532/)

