# 树状数组



## 功能：

1. 快速求前缀和 $O(\log n)$
2. 修改某一个数 $O(\log n)$



## 实现思想

对于任意 $x$，存在二进制表示 $x = 2^{i_k} + 2^{i_{k-1}} + ... + 2^{i_2} + 2^{i_1}$，其中 $i_k \ge i_{k-1} \ge i_{k-2} \ge ... \ge i_1$

则我们可以把 $1$~$x$ 进行区间划分: 
$$
\begin{align}
1).&(x - 2^{i_1}, x] \\
2).&(x - 2^{i_1} - 2^{i_2}, x - 2^{i_1}] \\
3).&(x - 2^{i_1} - 2^{i_2} - 2^{i_3}, x - 2^{i_1} - 2^{i_2}] \\
&.........\\
k-1).&(x - 2^{i_1} - ... - 2^{i_{k-1}}, x - 2^{i_1} - ... - 2^{i_{k-2}}] \\
k)  .&(0, x - 2^{i_1} - ... - 2^{i_{k-1}}] \\
\end{align}
$$
共 $\log x$ 个区间

这种设计思想，就可以让我们在 $\log n$的时间复杂度之内，向前`求前缀和`，或`向后修改包含某个数的所有区间`



对于上述中所有区间中任意一个区间 $(L, R]$，我们可以只依靠右端点来进行表示

于是就有 $C[R] = (R - lowbit(R), R]$。



通过使用一维数组来表示一个固定区间，于是我们就获得了树状数组。



树状数组的物理结构图

![image-20210413152827851](/Users/zhaoxiucong/Library/Application Support/typora-user-images/image-20210413152827851.png)

## 需要注意的点

1. 如何有效的`向前`或`向后`修改所有区间？

​	通过观察发现，需要修改的区间从小到大排序后，每个区间的长度是`指数`的`二进制表示`中的`最后一个1`，因此我们可以通过反复迭代`lowbit()`函数，进行区间的有效修改。

向前求前缀和：

```c++
for (int i = x; i; i -= lowbit(i))
    res += tr[i];
```

向后修改某个数(+w)：

```c++
for (int i = x; i <= n; i += lowbit(i))
    tr[i] += w;
```



2. 为什么`向后`修改是对的？

    通过子结点找父结点的过程是唯一的。

    对于任意的子结点 $x= ......011111000...0$ 来说，其存在唯一父结点 $x + lowbit(x) = ......100000000...0$

    对于任意点来说，都存在唯一父结点，所以这就是一棵`树`，而非`有向无环图`。

    

# 树状数组模版

```c++
int lowbit(int x)
{
    return x & -x;
}
int add(int x, int v)
{
    for (int i = x; i <= n; i += lowbit(i))
        tr[i] += v;
}
int query(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i))
        res += tr[i];
    return res;
}

//直接建树转数组
void build()
{
    for (int x = 1; x <= n; ++x)
        for (int i = x - 1; i >= x - lowbit(x) + 1; i -= lowbit(i))
            tr[x] += tr[i];
}
```

